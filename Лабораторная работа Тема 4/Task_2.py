def get_count_char(str_):
    """

    В данной функуции присутствует много параметров. Я не смог придумать, как оптимизировать решение более удачно.

    :param str_: это исходная строка, которую задает пользователь


    :var new_str_: это пустой список, в который в последствии попадают только слова без пробелов и разделителей строк
                    (\n). После этого данная переменная превращается с в строку без пробелов, однако мной было
                    обнаружено, что в ней остались ".", ",", "!" и "\n".

    :var new_str_2: также первоначально является пустым списком, в который в последствии попадают данные очищенные от
                    ".", ",", "!" и "\n".

    :var set_str: это множество образованное из new_str_2, которое необходимо, чтобы избавиться от повторения
                    и получить список букв.

    :var dict_1: это много маленьких словарей в которые попадает запись вида {'н': 13}.

    :var f: возвращает количество число равное количеству повторений буквы в фразе.
            Для этого она берет букву из множества set_str и проверяет сколько раз она появляется в списке new_str_2.
    :var dict_2: это словарь который объединяет в себя все словари dict_1.


    :return: в конечном итоге дання функция возвращает словарь (dict_2), содержащий информацию о том, как часто
            встречается буква в строке.

    """

    str_ = str_.lower().split(' ')
    new_str_ = []

    for i in str_:
        if i != '' and i != '\n':
            new_str_.append(i)

    new_str_ = ''.join(new_str_)
    new_str_2 = []

    for a in new_str_:
        if a.isalpha():
            new_str_2.append(a)

    dict2 = {}

    for g in new_str_2:
        f = new_str_2.count(g)
        dict1 = {new_str_2: f for new_str_2 in g}
        dict2.update(dict1)

    """
    Изначально делал через set (строка 58-64) поскольку при отработке решения, по другому не получалось. Я думал, что 
    при испльзовании кода написанного выше (строка 47-50) новый словарь будет в себя включать много повторений. То есть 
    каждый раз, когда цикл будет встречать букву, он будет заново вносить ее количество в словарь. 
    """

    # set_str = set(new_str_2)
    # dict2 = {}
    #
    # for b in set_str:
    #     f = new_str_2.count(b)
    #     dict1 = {new_str_2: f for new_str_2 in b}
    #     dict2.update(dict1)

    return dict2


...  # TODO посчитать количество каждой буквы в строке в аргументе str_

main_str = """
    Данное предложение будет разбиваться на отдельные слова. 
    В качестве разделителя для встроенного метода split будет выбран символ пробела. На выходе мы получим список отдельных слов. 
    Далее нужно отсортировать слова в алфавитном порядке, а после сортировки склеить их с помощью метода строк join. Приступим!!!!
"""
print(get_count_char(main_str))

# # Разработка решения
# a = 'ffffaaafgsdfsjgsd;lkkfkjhg'
#
# print(a)
#
# b = set(a)
# dict1 = {}
# for i in b:
#     f = a.count(i)
#     dict_ = {a: f for a in i}
#     dic1 = dict_
#     dict1.update(dict_)
#     # print(dict_)
#
#     print('Буква', i, 'встречается', f, 'раза')
# print(dict1)
